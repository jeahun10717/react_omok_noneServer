[{"/Users/seongjehun/Desktop/study/reactPrac/omok/src/index.js":"1","/Users/seongjehun/Desktop/study/reactPrac/omok/src/App.js":"2","/Users/seongjehun/Desktop/study/reactPrac/omok/src/components/Plate.js":"3","/Users/seongjehun/Desktop/study/reactPrac/omok/src/rules/winRule.js":"4","/Users/seongjehun/Desktop/study/reactPrac/omok/src/rules/prohibitRule.js":"5","/Users/seongjehun/Desktop/study/reactPrac/omok/src/rules/arrayCopy.js":"6"},{"size":409,"mtime":1624338017290,"results":"7","hashOfConfig":"8"},{"size":2465,"mtime":1625747568621,"results":"9","hashOfConfig":"8"},{"size":1764,"mtime":1625034606288,"results":"10","hashOfConfig":"8"},{"size":9637,"mtime":1625633048510,"results":"11","hashOfConfig":"8"},{"size":19532,"mtime":1625747374144,"results":"12","hashOfConfig":"8"},{"size":360,"mtime":1625188567553,"results":"13","hashOfConfig":"8"},{"filePath":"14","messages":"15","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"16"},"13l1nov",{"filePath":"17","messages":"18","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"19","messages":"20","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"16"},{"filePath":"21","messages":"22","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"16"},{"filePath":"23","messages":"24","errorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"25","usedDeprecatedRules":"16"},{"filePath":"26","messages":"27","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"16"},"/Users/seongjehun/Desktop/study/reactPrac/omok/src/index.js",[],["28","29"],"/Users/seongjehun/Desktop/study/reactPrac/omok/src/App.js",["30"],"/Users/seongjehun/Desktop/study/reactPrac/omok/src/components/Plate.js",[],"/Users/seongjehun/Desktop/study/reactPrac/omok/src/rules/winRule.js",[],"/Users/seongjehun/Desktop/study/reactPrac/omok/src/rules/prohibitRule.js",["31","32","33","34","35","36","37","38","39"],"const {\n    unstable_renderSubtreeIntoContainer\n} = require('react-dom');\nconst copyArr = require('../rules/arrayCopy')\n\nexports.prohibit3by3 = (plateArr, lineNum, i, j) => {\n    let tmpArr;\n    tmpArr = copyArr.arrayCopy(plateArr, tmpArr, lineNum);\n    let check3By3Arr = [];\n    for (let i = 0; i < 4; i++) {\n        check3By3Arr[i] = 1;\n    }\n    for (let depth = 1; depth < 4; depth++) {\n        if (i - depth >= 0) {\n            if (tmpArr[i - depth][j] === 1) {\n                check3By3Arr[0] = check3By3Arr[0] + tmpArr[i - depth][j] // Up\n            }\n\n        }\n        if (i + depth <= 14) {\n            if (tmpArr[i + depth][j] === 1) {\n                check3By3Arr[0] = check3By3Arr[0] + tmpArr[i + depth][j] // Down\n            }\n\n        }\n        if (i - depth >= 0 && j + depth <= 14) {\n            if (tmpArr[i - depth][j + depth] === 1) {\n                check3By3Arr[1] = check3By3Arr[1] + tmpArr[i - depth][j + depth] // Right Up\n            }\n\n        }\n        if (i + depth <= 14 && j - depth >= 0) {\n            if (tmpArr[i + depth][j - depth] === 1) {\n                check3By3Arr[1] = check3By3Arr[1] + tmpArr[i + depth][j - depth] // Left Down\n            }\n\n        }\n        if (j + depth <= 14) {\n            if (tmpArr[i][j + depth] === 1) {\n                check3By3Arr[2] = check3By3Arr[2] + tmpArr[i][j + depth] // Right\n            }\n\n        }\n        if (j - depth >= 0) {\n            if (tmpArr[i][j - depth] === 1) {\n                check3By3Arr[2] = check3By3Arr[2] + tmpArr[i][j - depth] // Left\n            }\n\n        }\n        if (i + depth <= 14 && j + depth <= 14) {\n            if (tmpArr[i + depth][j + depth] === 1) {\n                check3By3Arr[3] = check3By3Arr[3] + tmpArr[i + depth][j + depth] // Right Down           \n            }\n\n        }\n        if (i - depth >= 0 && j - depth >= 0) {\n            if (tmpArr[i - depth][j - depth] === 1) {\n                check3By3Arr[3] = check3By3Arr[3] + tmpArr[i - depth][j - depth] // Left Up\n            }\n\n        }\n        // const check3Num = check3By3Arr.filter(i=>3 === i).length;\n        // console.log(\"test!!!!!!!!!!1\", check3By3Arr);\n    }\n    let threeCnt = check3By3Arr.filter(element => element >= 3).length;\n\n    let threeState = Array.from(Array(4).fill(false))\n    if (threeCnt > 1) {\n        // 3 라인일 때\n        for (let q = 0; q < 4; q++) {\n            if (check3By3Arr[q] === 3) {\n                if (threeLineChk(tmpArr, q, i, j) === \"3By3\") {\n                    threeState[q] = true\n                } else if (threeLineChk(tmpArr, q, i, j) === \"none3By3\") {\n                    threeState[q] = false\n                }\n            }\n        }\n        // 4 라인일 떄 \n    }\n    // console.log(threeState);\n    if (threeState.filter(i => i === true).length >= 2) {\n        return \"prohibit\"\n    }\n    // if(threeCnt>1) {\n    //     \n    //     // console.log(threeState);\n    //     // console.log(threeState.find(element=>element===0));\n    //     if(threeState.find(element=>element===0)){\n\n    //     }else if(threeState.find(element=>element===0)){\n\n    //     }else if(threeState.find(element=>element===0)){\n\n    //     }else if(threeState.find(element=>element===0)){\n\n    //     }\n    // }\n}\n\nfunction threeLineChk(arr, line, i, j) { // line 은 방향\n    if (line === 0) {\n        let blackCnt = 0;\n        let firstBlack = [];\n        let lastBlack = [];\n        let tmpBlackArr = [];\n        for (let x = 0; x < 7; x++) { // 위에서부터 차례로\n            if (i - 3 + x >= 0 && i - 3 + x <= 14) { // 7개를 차례로 보되 인덱스가 0 이하 14 이상은 배열이 없으므로 패스\n\n                if (arr[i - 3 + x][j] === 1) {\n                    blackCnt++\n                }\n                if (blackCnt === 1 && arr[i - 3 + x][j] === 1) {\n                    firstBlack = [i - 3 + x, j]\n                }\n                if (blackCnt === 3 && arr[i - 3 + x][j] === 1) {\n                    lastBlack = [i - 3 + x, j]\n                }\n            }\n        }\n        for (let y = 0; y < (lastBlack[0] - firstBlack[0]) + 1; y++) {\n            tmpBlackArr[y] = arr[firstBlack[0] + y][firstBlack[1]]\n        }\n        if (tmpBlackArr.length <= 4) { // 4칸 이\n            if (tmpBlackArr.filter(i => i === -1).length === 1) {\n                return \"none3By3\"\n            } else {\n                if (firstBlack[0] - 1 < 0 || lastBlack[0] + 1 > 14) { // 3개 놓은 돌 중에 위아래가 벽인 경우\n                    return \"none3By3\"\n                } else if (arr[firstBlack[0] - 1][firstBlack[1]] === -1 || arr[lastBlack[0] + 1][lastBlack[1]] === -1) {\n                    return \"none3By3\"\n                } else if (arr[firstBlack[0] - 1][firstBlack[1]] === 0 && arr[lastBlack[0] + 1][lastBlack[1]] === 0) {\n                    return \"3By3\"\n                }\n            }\n        } else {\n            return \"none3By3\"\n        }\n    } else if (line === 1) {\n        let blackCnt = 0;\n        let firstBlack = [];\n        let lastBlack = [];\n        let tmpBlackArr = [];\n        for (let x = 0; x < 7; x++) { // 위에서부터 차례로\n            if (i - 3 + x >= 0 && i - 3 + x <= 14 && j + 3 - x >= 0 && j + 3 - x <= 14) { // 7개를 차례로 보되 인덱스가 0 이하 14 이상은 배열이 없으므로 패스\n\n                if (arr[i - 3 + x][j + 3 - x] === 1) {\n                    blackCnt++\n                }\n                if (blackCnt === 1 && arr[i - 3 + x][j + 3 - x] === 1) {\n                    firstBlack = [i - 3 + x, j + 3 - x]\n                }\n                if (blackCnt === 3 && arr[i - 3 + x][j + 3 - x] === 1) {\n                    lastBlack = [i - 3 + x, j + 3 - x]\n                }\n            }\n        }\n        for (let y = 0; y < (lastBlack[0] - firstBlack[0]) + 1; y++) {\n            tmpBlackArr[y] = arr[firstBlack[0] + y][firstBlack[1] - y]\n        }\n        if (tmpBlackArr.length <= 4) { // 4칸 이\n            if (tmpBlackArr.filter(i => i === -1).length === 1) {\n                return \"none3By3\"\n            } else {\n                if ((firstBlack[0] - 1 < 0 && firstBlack[1] + 1 > 14) || (lastBlack[0] + 1 > 14 && lastBlack[0] - 1 < 0)) { // 3개 놓은 돌 중에 위아래가 벽인 경우\n                    return \"none3By3\"\n                } else if (arr[firstBlack[0] - 1][firstBlack[1] + 1] === -1 || arr[lastBlack[0] + 1][lastBlack[1] - 1] === -1) {\n                    return \"none3By3\"\n                } else if (arr[firstBlack[0] - 1][firstBlack[1] + 1] === 0 && arr[lastBlack[0] + 1][lastBlack[1] - 1] === 0) {\n                    return \"3By3\"\n                }\n            }\n        } else {\n            return \"none3By3\"\n        }\n    } else if (line === 2) {\n        let blackCnt = 0;\n        let firstBlack = [];\n        let lastBlack = [];\n        let tmpBlackArr = [];\n        for (let x = 0; x < 7; x++) { // 위에서부터 차례로\n            if (j + 3 - x >= 0 && j + 3 - x <= 14) { // 7개를 차례로 보되 인덱스가 0 이하 14 이상은 배열이 없으므로 패스\n\n                if (arr[i][j + 3 - x] === 1) {\n                    blackCnt++\n                }\n                if (blackCnt === 1 && arr[i][j + 3 - x] === 1) {\n                    firstBlack = [i, j + 3 - x]\n                }\n                if (blackCnt === 3 && arr[i][j + 3 - x] === 1) {\n                    lastBlack = [i, j + 3 - x]\n                }\n            }\n        }\n        for (let x = 0; x < (firstBlack[1] - lastBlack[1]) + 1; x++) {\n            tmpBlackArr[x] = arr[firstBlack[0]][firstBlack[1] - x]\n        }\n        if (tmpBlackArr.length <= 4) { // 4칸 이\n            if (tmpBlackArr.filter(i => i === -1).length === 1) {\n                return \"none3By3\"\n            } else {\n                if (firstBlack[1] + 1 > 14 || lastBlack[1] - 1 < 0) { // 3개 놓은 돌 중에 위아래가 벽인 경우\n                    return \"none3By3\"\n                } else if (arr[firstBlack[0]][firstBlack[1] + 1] === -1 || arr[lastBlack[0]][lastBlack[1] - 1] === -1) {\n                    return \"none3By3\"\n                } else if (arr[firstBlack[0]][firstBlack[1] + 1] === 0 && arr[lastBlack[0]][lastBlack[1] - 1] === 0) {\n                    return \"3By3\"\n                }\n            }\n        } else {\n            return \"none3By3\"\n        }\n    } else if (line === 3) {\n        let blackCnt = 0;\n        let firstBlack = [];\n        let lastBlack = [];\n        let tmpBlackArr = [];\n        for (let x = 0; x < 7; x++) { // 위에서부터 차례로\n            if (i + 3 - x >= 0 && i + 3 - x <= 14 && j + 3 - x >= 0 && j + 3 - x <= 14) { // 7개를 차례로 보되 인덱스가 0 이하 14 이상은 배열이 없으므로 패스\n\n                if (arr[i + 3 - x][j + 3 - x] === 1) {\n                    blackCnt++\n                }\n                if (blackCnt === 1 && arr[i + 3 - x][j + 3 - x]) {\n                    firstBlack = [i + 3 - x, j + 3 - x]\n                }\n                if (blackCnt === 3 && arr[i + 3 - x][j + 3 - x]) {\n                    lastBlack = [i + 3 - x, j + 3 - x]\n                }\n            }\n        }\n        for (let y = 0; y < (lastBlack[0] - firstBlack[0]) + 1; y++) {\n            tmpBlackArr[y] = arr[firstBlack[0] - y][firstBlack[1] - y]\n        }\n        if (tmpBlackArr.length <= 4) { // 4칸 이\n            if (tmpBlackArr.filter(i => i === -1).length === 1) {\n                return \"none3By3\"\n            } else {\n                if ((firstBlack[0] + 1 > 14 && firstBlack[1] + 1 > 14) || (lastBlack[0] - 1 < 0 && lastBlack[0] - 1 < 0)) { // 3개 놓은 돌 중에 위아래가 벽인 경우\n                    return \"none3By3\"\n                } else if (arr[firstBlack[0] + 1][firstBlack[1] + 1] === -1 || arr[lastBlack[0] - 1][lastBlack[1] - 1] === -1) {\n                    return \"none3By3\"\n                } else if (arr[firstBlack[0] + 1][firstBlack[1] + 1] === 0 && arr[lastBlack[0] - 1][lastBlack[1] - 1] === 0) {\n                    return \"3By3\"\n                }\n            }\n        } else {\n            return \"none3By3\"\n        }\n    }\n}\n\nexports.prohibit4By4 = (plateArr, lineNum, i, j) => {\n    let tmpArr;\n    tmpArr = copyArr.arrayCopy(plateArr, tmpArr, lineNum);\n    let check4By4Arr = [];\n    for (let x = 0; x < 4; x++) {\n        check4By4Arr[x] = fourBlackCnt(tmpArr, x, i, j);\n    }\n    let fourState = Array.from(Array(4).fill(false))\n    if (check4By4Arr.filter(element => element === 4).length >= 2) { // 1줄에 4인개 2개 이상일 때\n        for (let x = 0; x < 4; x++) {\n            if (check4By4Arr[x] === 4) { // 4개인 부붙의 인덱스를 확인하기 위한 for 문\n                let fourChk = fourCheck(tmpArr, x, i, j);\n                console.log(fourChk, \"hhhhhhhhhhhhh\");\n                if (fourChk === \"4By4\") {\n                    fourState[x] = true;\n                } else if (fourChk === \"none4By4\") {\n                    fourState[x] = false;\n                }\n            }\n        }\n    } else if (check4By4Arr.filter(element => element === 5).length === 1) {\n        for (let x = 0; x < 4; x++) {\n            if(check4By4Arr[x] === 5){\n                let fourFiveChk = five4By4Check(tmpArr, x, i, j);\n                if(fourFiveChk === \"4By4\"){\n                    return \"prohibit\";\n                }\n            }\n        }\n    } else if (check4By4Arr.filter(element => element === 6).length === 1) {\n\n    } else if (check4By4Arr.filter(element => element === 7).length === 1) {\n\n    }\n    console.log(fourState);\n    if (fourState.filter(element => element === true).length >= 2) {\n        return \"prohibit\"\n    }\n}\n\nfunction five4By4Check(arr, line, i, j) {\n    if (line === 0) {\n        if (i - 3 >= 0 && i + 3 <= 14) {\n            if( arr[i-3][j]===1 && arr[i-2][j]===0 &&\n                arr[i-1][j]===1 && arr[i][j]===1 && \n                arr[i+1][j]===1 && arr[i+2][j]===0 && arr[i+3][j]===1 ){return \"4By4\"}\n            else{ return \"none4By4\"}\n        }\n    } else if (line === 1) {\n        if (i + 3 <= 14 && j - 3 >= 0 && i - 3 >= 0 && j + 3 <= 14) {\n            if(arr[i+3][j-3]===1 && arr[i+2][j-2]===0 && \n                arr[i+1][j-1]===1 && arr[i][j]===1 && arr[i-1][j+1]===1 && \n                arr[i-2][j+2]===0 && arr[i-3][j+3]===1){return \"4By4\"}\n            else{ return \"none4By4\"}\n        }\n    } else if (line === 2) {\n        if (j+3<=14 && j-3>=0){\n            if(arr[i][j-3] === 1 && arr[i][j-2] === 0 && arr[i][j-1] === 1 &&\n                 arr[i][j] === 1 && arr[i][j+1] === 1 && arr[i][j+2] === 0 && arr[i][j+3] === 1){return \"4By4\"}\n            else{ return \"none4By4\"}\n        }\n    } else if (line === 3) {\n        if(i+3<=14 && j+3<=14 && i-3>=0 && j-3>=0){\n            if(arr[i-3][j-3]===1 && arr[i-2][j-2]===0 && arr[i-1][j-1]===1 && \n                arr[i][j]===1 && arr[i+1][j+1]===1 && arr[i+2][j+2]===0 && arr[i+3][j+3]===1){return \"4By4\"}\n            else{ return \"none4By4\"}\n        }\n    }\n}\n\n\nfunction fourCheck(arr, line, i, j) {\n    if (line === 0) {\n        let firstBlack = [];\n        let lastBlack = [];\n        let tmpBlackArr = [];\n        let blackCnt = 0;\n        for (let k = -4; k <= 4; k++) {\n            if (i + k >= 0 && i + k <= 14) { // UP to DOWN : i 의 범위는 0~14까지만 가능\n                if (arr[i + k][j] === 1) {\n                    blackCnt++;\n                }\n                if (blackCnt === 1 && arr[i + k][j] === 1) {\n                    firstBlack = [i + k, j]\n                }\n                if (blackCnt === 4 && arr[i + k][j] === 1) {\n                    lastBlack = [i + k, j]\n                }\n            }\n        }\n        for (let y = 0; y < (lastBlack[0] - firstBlack[0] + 1); y++) {\n            tmpBlackArr[y] = arr[firstBlack[0] + y][firstBlack[1]]\n        }\n        if (tmpBlackArr.length <= 5) {\n            if (tmpBlackArr.filter(element => element === -1).length === 1) {\n                return \"none4By4\"\n            } else {\n                return \"4By4\"\n            }\n        }\n    } else if (line === 1) {\n        let firstBlack = [];\n        let lastBlack = [];\n        let tmpBlackArr = [];\n        let blackCnt = 0;\n        for (let k = -4; k <= 4; k++) {\n            if (i + k >= 0 && i + k <= 14 && j - k >= 0 && j - k <= 14) { // RIGHT_UP to LEFT_DOWN : i 의 범위는 0~14까지만 가능\n                if (arr[i + k][j - k] === 1) {\n                    blackCnt++;\n                }\n                if (blackCnt === 1 && arr[i + k][j - k] === 1) {\n                    firstBlack = [i + k, j - k]\n                }\n                if (blackCnt === 4 && arr[i + k][j - k] === 1) {\n                    lastBlack = [i + k, j - k]\n                }\n            }\n        }\n        for (let y = 0; y < (lastBlack[0] - firstBlack[0]) + 1; y++) {\n            tmpBlackArr[y] = arr[firstBlack[0] + y][firstBlack[1] - y]\n        }\n        if (tmpBlackArr.length <= 5) {\n            if (tmpBlackArr.filter(element => element === -1).length === 1) {\n                return \"none4By4\"\n            } else {\n                return \"4By4\"\n            }\n        }\n    } else if (line === 2) {\n        let firstBlack = [];\n        let lastBlack = [];\n        let tmpBlackArr = [];\n        let blackCnt = 0;\n        for (let k = -4; k <= 4; k++) {\n            if (j + k >= 0 && j + k <= 14) { // DOWN TO UP : i 의 범위는 0~14까지만 가능\n                if (arr[i][j - k] === 1) {\n                    blackCnt++;\n                }\n                if (blackCnt === 1 && arr[i][j - k] === 1) {\n                    firstBlack = [i, j - k]\n                }\n                if (blackCnt === 4 && arr[i][j - k] === 1) {\n                    lastBlack = [i, j - k]\n                }\n            }\n        }\n        for (let x = 0; x < (firstBlack[1] - lastBlack[1]) + 1; x++) {\n            tmpBlackArr[x] = arr[firstBlack[0]][firstBlack[1] - x]\n        }\n\n        if (tmpBlackArr.length <= 5) {\n            if (tmpBlackArr.filter(element => element === -1).length === 1) {\n                return \"none4By4\"\n            } else {\n                return \"4By4\"\n            }\n        }\n    } else if (line === 3) {\n        let firstBlack = [];\n        let lastBlack = [];\n        let tmpBlackArr = [];\n        let blackCnt = 0;\n        for (let k = -4; k <= 4; k++) {\n            if (i - k >= 0 && i - k <= 14 && j - k >= 0 && j - k <= 14) { // RIGHT_DOWN to LEFT_UP : i 의 범위는 0~14까지만 가능\n                if (arr[i - k][j - k] === 1) {\n                    blackCnt++;\n                }\n                if (blackCnt === 1 && arr[i - k][j - k] === 1) {\n                    firstBlack = [i - k, j - k]\n                }\n                if (blackCnt === 4 && arr[i - k][j - k] === 1) {\n                    lastBlack = [i - k, j - k]\n                }\n            }\n        }\n        for (let y = 0; y < (lastBlack[0] - firstBlack[0]) + 1; y++) {\n            tmpBlackArr[y] = arr[firstBlack[0] - y][firstBlack[1] - y]\n        }\n        console.log(tmpBlackArr, \"asdlkfjaldsfjlasdjkfladjsadslfjalsdkfjasljk\");\n        if (tmpBlackArr.length <= 5) {\n            if (tmpBlackArr.filter(element => element === -1).length === 1) {\n                return \"none4By4\"\n            } else {\n                return \"4By4\"\n            }\n        }\n\n    }\n}\n\nfunction fourBlackCnt(arr, line, i, j) { // 착수지점 기준으로 4방향의 배열에서 흑돌이 갯수 측정\n    if (line === 0) {\n        let firstBlack = [];\n        let lastBlack = [];\n        let blackCnt = 0;\n        for (let k = -4; k <= 4; k++) {\n            if (i + k >= 0 && i + k <= 14) { // UP to DOWN : i 의 범위는 0~14까지만 가능\n                if (arr[i + k][j] === 1) {\n                    blackCnt++;\n                }\n                //     if(blackCnt === 1 && arr[i + k][j]){\n                //         firstBlack = [i + k, j]\n                //     }\n                //     if(blackCnt === 4 && arr[i + k][j]){\n                //         lastBlack = [i + k][j]\n                //     }\n                // }\n            }\n            // if(blackCnt === 4){ // 검은돌이 4개 나왔을 때\n            //     if(lastBlack[0]-firstBlack[0]===4){ // 검은돌이 5개 이하 일 때\n\n            //     }else if(lastBlack[0]-firstBlack[0]===5){\n\n            //     }\n        }\n        return blackCnt;\n    } else if (line === 1) {\n        let firstBlack = [];\n        let lastBlack = [];\n        let blackCnt = 0;\n        for (let k = -4; k <= 4; k++) {\n            if (i + k >= 0 && i + k <= 14 && j - k >= 0 && j - k <= 14) { // RIGHT_UP to LEFT_DOWN : i 의 범위는 0~14까지만 가능\n                if (arr[i + k][j - k] === 1) {\n                    blackCnt++;\n                }\n            }\n        }\n        return blackCnt;\n    } else if (line === 2) {\n        let firstBlack = [];\n        let lastBlack = [];\n        let blackCnt = 0;\n        for (let k = -4; k <= 4; k++) {\n            if (j + k >= 0 && j + k <= 14) { // DOWN TO UP : i 의 범위는 0~14까지만 가능\n                if (arr[i][j - k] === 1) {\n                    blackCnt++;\n                }\n            }\n        }\n        return blackCnt;\n    } else if (line === 3) {\n        let firstBlack = [];\n        let lastBlack = [];\n        let blackCnt = 0;\n        for (let k = -4; k <= 4; k++) {\n            if (i - k >= 0 && i - k <= 14 && j - k >= 0 && j - k <= 14) { // RIGHT_DOWN to LEFT_UP : i 의 범위는 0~14까지만 가능\n                if (arr[i - k][j - k] === 1) {\n                    blackCnt++;\n                }\n            }\n        }\n        return blackCnt;\n    }\n}","/Users/seongjehun/Desktop/study/reactPrac/omok/src/rules/arrayCopy.js",[],{"ruleId":"40","replacedBy":"41"},{"ruleId":"42","replacedBy":"43"},{"ruleId":"44","severity":1,"message":"45","line":9,"column":7,"nodeType":"46","messageId":"47","endLine":9,"endColumn":17},{"ruleId":"44","severity":1,"message":"48","line":2,"column":5,"nodeType":"46","messageId":"47","endLine":2,"endColumn":40},{"ruleId":"44","severity":1,"message":"49","line":445,"column":13,"nodeType":"46","messageId":"47","endLine":445,"endColumn":23},{"ruleId":"44","severity":1,"message":"50","line":446,"column":13,"nodeType":"46","messageId":"47","endLine":446,"endColumn":22},{"ruleId":"44","severity":1,"message":"49","line":470,"column":13,"nodeType":"46","messageId":"47","endLine":470,"endColumn":23},{"ruleId":"44","severity":1,"message":"50","line":471,"column":13,"nodeType":"46","messageId":"47","endLine":471,"endColumn":22},{"ruleId":"44","severity":1,"message":"49","line":482,"column":13,"nodeType":"46","messageId":"47","endLine":482,"endColumn":23},{"ruleId":"44","severity":1,"message":"50","line":483,"column":13,"nodeType":"46","messageId":"47","endLine":483,"endColumn":22},{"ruleId":"44","severity":1,"message":"49","line":494,"column":13,"nodeType":"46","messageId":"47","endLine":494,"endColumn":23},{"ruleId":"44","severity":1,"message":"50","line":495,"column":13,"nodeType":"46","messageId":"47","endLine":495,"endColumn":22},"no-native-reassign",["51"],"no-negated-in-lhs",["52"],"no-unused-vars","'emptyPlate' is assigned a value but never used.","Identifier","unusedVar","'unstable_renderSubtreeIntoContainer' is assigned a value but never used.","'firstBlack' is assigned a value but never used.","'lastBlack' is assigned a value but never used.","no-global-assign","no-unsafe-negation"]